/**
* @file  protocol.c
* @brief this file contains protocol analysis and construct response function when received rf module send message
* @author LinhTran
* @date 2023.08.11
* @par email:tranngoclinh.cdt@gmail.com
* @copyright Freelux CO.,LTD
* @par company
*
*/
// #include "main.h"
#include "zigbee_define.h"
#include "protocol_define.h"
// #include "AppTask.h"
// #include "dimmer_high_level.h"

#pragma pack(1)

///> dp data list, this will be generated by cloud platform
extern const DOWNLOAD_CMD_S download_cmd[];

extern unsigned char cmd_total;
device_info deviceInfo;

static void report_mcu_ota_result(unsigned char  res);


/**
* @brief encapsulates a generic send function, developer should use their own function to completing this fuction 
* @param[in] {value} send signle data 
* @return  void
*/
void uart_transmit_output(unsigned char value)
{
 // #error "please use your own uart send fuction complete this fuction, exmaple"
/*
*  //demo:
*  extern void Uart_PutChar(unsigned char value);
*  Uart_PutChar(value);	                             
*/
}


/**
* @brief Upload all dp information of the system, and realize the synchronization of APP and muc data
* @param[in] {void}
* @return  void
*/
void all_data_update(void)
{
	int i=0;
 // #error "mcu must realize function internal function"
   /*
  * these fucntion will be generated by cloud platform, but when use these function must reference the function in  mcu_api.c
 */

	
	for(i=0;i< NUMBER_CHANNEL_IN_DEVICE ;i++){
    mcu_dp_bool_update(DPID_SWITCH_LED_1 + i*16,deviceInfo.driver[i].dimSwitchState);
    mcu_dp_value_update(DPID_BRIGHT_VALUE_1 + i*16,deviceInfo.driver[i].dimValueExpect); 

   // mcu_dp_value_update(DPID_BRIGHTNESS_MIN_1 + i*16,deviceInfo.driver[i].dimLevelMin); 
   // mcu_dp_enum_update(DPID_LED_TYPE_1 + i*16,deviceInfo.driver[i].lamType); 
   // mcu_dp_value_update(DPID_BRIGHTNESS_MAX_1 + i*16,deviceInfo.driver[i].dimLevelMax); 
   // mcu_dp_value_update(DPID_TRANSACTION_1 + i*16,deviceInfo.driver[i].transaction); 
		
	}
	
	//mcu_dp_enum_update(DPID_RESTART_STATUS,0); 
	//mcu_dp_enum_update(DPID_LIGHT_MODE,0); 
	
}



static unsigned char dp_download_switch_led_handle(char channel, const unsigned char value[], unsigned short length)
{
    unsigned char ret;
    //0:off/1:on
    unsigned char switch_led;
    
    //deviceInfo.driver[channel].dimSwitchState = mcu_get_dp_download_bool(value,length);
		// DIM_SetPara(channel,SET_SWITCH_STATE, mcu_get_dp_download_bool(value,length));
    ret = mcu_dp_bool_update(DPID_SWITCH_LED_1+channel*16,deviceInfo.driver[channel].dimSwitchState);
		if(deviceInfo.driver[channel].dimSwitchState !=0){
			ret = mcu_dp_value_update(DPID_BRIGHT_VALUE_1+channel*16,deviceInfo.driver[channel].dimValueExpect);
		}
	
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}

static unsigned char dp_download_bright_value_handle(char channel,const unsigned char value[], unsigned short length)
{

    unsigned char ret;
    unsigned long bright_value_1;
    

		// DIM_SetPara(channel,SET_DIM_VALUE_EXPECT,mcu_get_dp_download_value(value,length));
	
    //There should be a report after processing the DP
    ret = mcu_dp_value_update(DPID_BRIGHT_VALUE_1+channel*16,deviceInfo.driver[channel].dimValueExpect);
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}

static unsigned char dp_download_brightness_min_handle(char channel,const unsigned char value[], unsigned short length)
{
    unsigned char ret;
    unsigned long brightness_min_1;
    
    //deviceInfo.driver[channel].dimLevelMin = mcu_get_dp_download_value(value,length);
		// DIM_SetPara(channel,SET_DIM_DIM_MIN,mcu_get_dp_download_value(value,length));
    /*
    //VALUE type data processing
    
    */
    
    //There should be a report after processing the DP
    ret = mcu_dp_value_update(DPID_BRIGHTNESS_MIN_1+channel*16,deviceInfo.driver[channel].dimLevelMin);
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}

static unsigned char dp_download_led_type_handle(char channel,const unsigned char value[], unsigned short length)
{
    unsigned char ret;
    
    //deviceInfo.driver[channel].lamType = mcu_get_dp_download_enum(value,length);
		// DIM_SetPara(channel,SET_LAMP_TYPE,mcu_get_dp_download_enum(value,length));
	
    switch(deviceInfo.driver[channel].lamType) {
        case 0:
        break;
        
        case 1:
        break;
        
        case 2:
        break;
        
        default:
    
        break;
    }
    
    //There should be a report after processing the DP
    ret = mcu_dp_enum_update(DPID_LED_TYPE_1+channel*16, deviceInfo.driver[channel].lamType);
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}

static unsigned char dp_download_brightness_max_handle(char channel,const unsigned char value[], unsigned short length)
{

    unsigned char ret;
    
   // deviceInfo.driver[channel].dimLevelMax = mcu_get_dp_download_value(value,length);
		// DIM_SetPara(channel,SET_DIM_MAX,mcu_get_dp_download_value(value,length));
    /*
    //VALUE type data processing
    
    */
    
    //There should be a report after processing the DP
    ret = mcu_dp_value_update(DPID_BRIGHTNESS_MAX_1+channel*16,deviceInfo.driver[channel].dimLevelMax);
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}
static unsigned char dp_download_transaction_time_handle(char channel,const unsigned char value[], unsigned short length)
{
    unsigned char ret;
    unsigned long countdown_1;
    
    //deviceInfo.driver[channel].transaction = mcu_get_dp_download_value(value,length);


	// DIM_SetPara(channel,SET_TRANSACTION_TIME,mcu_get_dp_download_value(value,length));
	
    /*
    //VALUE type data processing
    
    */
    
    //There should be a report after processing the DP
    ret = mcu_dp_value_update(DPID_TRANSACTION_1+channel*16,deviceInfo.driver[channel].transaction);
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}


static unsigned char dp_download_restart_status_handle(const unsigned char value[], unsigned short length)
{
  unsigned char ret;
    
 // deviceInfo.restart_status = mcu_get_dp_download_enum(value,length);
	// DIM_SetPara(0xff,SET_RESTART_STATUS,mcu_get_dp_download_enum(value,length));
	
    
    //There should be a report after processing the DP
		ret =  mcu_dp_enum_update(DPID_RESTART_STATUS,deviceInfo.driver[0].restartStauts);
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}


static unsigned char dp_download_light_mode_handle(char channel,const unsigned char value[], unsigned short length)
{
    unsigned char ret;

    //deviceInfo.driver[channel].lightMode	= mcu_get_dp_download_enum(value,length);
		// DIM_SetPara(channel,SET_LIGHT_MODE,mcu_get_dp_download_enum(value,length));
	
    
    //There should be a report after processing the DP
    ret = mcu_dp_enum_update(DPID_LIGHT_MODE_1+channel*16, deviceInfo.driver[channel].lightMode);
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}

void respond_cct_or_hsl(char channel){
	  unsigned char reportValue[10] ={0};
		
	#ifdef DEVICE_LED_STRING_RGB //RGB hsl para:

		
		reportValue[0] = (unsigned char)(((int)deviceInfo.driver[channel].dimValueExpect>>8) & 0xff) ;
		reportValue[1] = (unsigned char)(((int)deviceInfo.driver[channel].dimValueExpect>>0) & 0xff) ;
		reportValue[2] = (unsigned char)(((int)deviceInfo.driver[channel].hue>>8) & 0xff) ;
		reportValue[3] = (unsigned char)(((int)deviceInfo.driver[channel].hue>>0) & 0xff) ;
		reportValue[4] = (unsigned char)(((int)deviceInfo.driver[channel].saturation>>8) & 0xff) ;
		reportValue[5] = (unsigned char)(((int)deviceInfo.driver[channel].saturation>>0) & 0xff) ;
		
		mcu_dp_raw_update(DPID_CCT_OR_HSL_1+channel*16,reportValue,6);
#else //CCT Lamp: cct para
		
		reportValue[0] = (unsigned char)(((int)deviceInfo.driver[channel].dimValueExpect>>8) & 0xff) ;
		reportValue[1] = (unsigned char)(((int)deviceInfo.driver[channel].dimValueExpect>>0) & 0xff) ;
		reportValue[2] = (unsigned char)(((int)deviceInfo.driver[channel].temperaColor>>8) & 0xff) ;
		reportValue[3] = (unsigned char)(((int)deviceInfo.driver[channel].temperaColor>>0) & 0xff) ;
	
		mcu_dp_raw_update(DPID_CCT_OR_HSL_1+channel*16,reportValue,4);
#endif
}

static unsigned char dp_download_cct_or_hsl_value_handle(char channel,const unsigned char value[], unsigned short length)
{

    unsigned char ret;
    unsigned long bright_value_1;
    unsigned char reportValue[10] ={0};
	
#ifdef DEVICE_LED_STRING_RGB //RGB hsl para:
		DIM_SetPara(channel,SET_DIM_VALUE_EXPECT,mcu_get_dp_download_value_2byte(value,length));
		DIM_SetPara(channel,SET_HUE_PARA,mcu_get_dp_download_value_2byte((value+2),length));
		DIM_SetPara(channel,SET_SATURATION,mcu_get_dp_download_value_2byte((value+4),length));
		
		respond_cct_or_hsl(channel);
#else //CCT Lamp: cct para
		// DIM_SetPara(channel,SET_DIM_VALUE_EXPECT,mcu_get_dp_download_value_2byte(value,length));
		// DIM_SetPara(channel,SET_TERMPERA_COLOR,mcu_get_dp_download_value_2byte((value+2),length));
		
		respond_cct_or_hsl(channel);
#endif

	
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}

static unsigned char dp_download_hue_or_tempercolor_value_handle(char channel,const unsigned char value[], unsigned short length)
{

    unsigned char ret;
    unsigned long value_1;
    
	
		value_1 = mcu_get_dp_download_value(value,length);
#ifdef DEVICE_LED_STRING_RGB //RGB hsl para:
		DIM_SetPara(channel,SET_HUE_PARA,value_1);
		
#else //CCT Lamp: cct para
		// DIM_SetPara(channel,SET_TERMPERA_COLOR,value_1);
#endif
	
    //There should be a report after processing the DP
    ret = mcu_dp_value_update(DPID_TERMP_OR_HUE_1+channel*16,value_1);
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}
static unsigned char dp_download_saturation_value_handle(char channel,const unsigned char value[], unsigned short length)
{

    unsigned char ret;
    unsigned long value_1;
    
	
		value_1 = mcu_get_dp_download_value(value,length);
		// DIM_SetPara(channel,SET_SATURATION,value_1);
	
    //There should be a report after processing the DP
    ret = mcu_dp_value_update(DPID_SATURATION_1+channel*16,value_1);
    if(ret == SUCCESS)
        return SUCCESS;
    else
        return ERROR;
}

#ifdef SUPPORT_MCU_RTC_CHECK
/**
* @brief mcu check local RTC time 
* @param[in] {time} timestamp
* @return  void
*/
void mcu_write_rtctime(unsigned char time[])
{
  #error "mcu should realize RTC time wtriting fuction, and delete this line"
  /*
  time[0]~time[3]：standard time
  time[4]~time[7]: Local time
 */
	my_memcpy((void *)timestamp,(const char *)time,4);	//get timestamp
	rf_timestamp_to_time();	
/*
	year = _time.w_year;	//year
	month = _time.w_month;	//month
	date = _time.w_date;	//date
	hour = _time.hour + 8;	//hour(8:BeiJing time)
	min = _time.min;	//minute
	sec = _time.sec;	//second
*/
}
#endif


/**
* @brief Zigbee functional test feedback
* @param[in] {void} 
* @return  void
*/
void rf_test_result(void)
{
	//#error "this test is makesure the rf fuction of rf module, if test pass or not should do something, mcu should realize"
	unsigned char rssi = rf_uart_rx_buf[DATA_START+1];

	if(rf_uart_rx_buf[DATA_START]== 0x01){
		if(rssi > 0x3C)	{
			//test sucess the range of rssi is 0% ~ 100%
		}
		else{
			//test failure
		}
	}
	else{
		//test failure
	}
}

/******************************************************************************
                                WARNING!!!                     
******************************************************************************/

/**
* @brief this function will handle uart received frame data  
* @param[in] {dpid}   dp id
* @param[in] {value}  dp data 
* @param[in] {length} lenght of dp data 
* @return  handle result 
*/
unsigned char dp_download_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
{
	unsigned char i;
  /* only list of function, mcu need realize these fuction*/
  unsigned char ret;
	
	for(i=0;i<NUMBER_CHANNEL_IN_DEVICE;i++){
		if(dpid == (DPID_SWITCH_LED_1 + i*16)){
			ret = dp_download_switch_led_handle(i,value,length);
			return ret;
		}
		else if(dpid ==  (DPID_BRIGHT_VALUE_1 + i*16)){
			ret = dp_download_bright_value_handle(i,value,length);
			return ret;
		}
		else if(dpid == (DPID_BRIGHTNESS_MIN_1 + i*16)){
			ret = dp_download_brightness_min_handle(i,value,length);
			return ret;
		}
		else if(dpid == (DPID_LED_TYPE_1 + i*16)){
			ret = dp_download_led_type_handle(i,value,length);
			return ret;
		}
		else if(dpid == (DPID_BRIGHTNESS_MAX_1 + i*16)){
			ret = dp_download_brightness_max_handle(i,value,length);
			return ret;
		}
		else if(dpid == (DPID_TRANSACTION_1 +i*16)){
			ret = dp_download_transaction_time_handle(i,value,length);
			return ret;
		}
		else if(dpid == (DPID_LIGHT_MODE_1 +i*16)){
			ret = dp_download_light_mode_handle(i,value,length);
			return ret;
		}
		else if(dpid == (DPID_CCT_OR_HSL_1 +i*16)){
			
			ret = dp_download_cct_or_hsl_value_handle(i, value, length);
			return ret;
		}
		else if(dpid == (DPID_TERMP_OR_HUE_1 +i*16)){
			
			ret = dp_download_hue_or_tempercolor_value_handle(i, value, length);
			return ret;
		}
		else if(dpid == (DPID_SATURATION_1 +i*16)){
			
			ret = dp_download_saturation_value_handle(i, value, length);
			return ret;
		}
		
	}
	
	if(dpid == (DPID_RESTART_STATUS )){
		ret = dp_download_restart_status_handle(value,length);
	}

  return ret;
}


unsigned char dp_respond_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
{
	unsigned char i;
  /* only list of function, mcu need realize these fuction*/
  unsigned char ret;
	
	for(i=0;i<NUMBER_CHANNEL_IN_DEVICE;i++){
		if(dpid == (DPID_SWITCH_LED_1 + i*16)){
			ret = mcu_dp_bool_update(dpid,deviceInfo.driver[i].dimSwitchState);
			return ret;
		}
		else if(dpid ==  (DPID_BRIGHT_VALUE_1 + i*16)){
			ret = mcu_dp_value_update(dpid,(unsigned long)deviceInfo.driver[i].dimValueExpect);
			return ret;
		}
		else if(dpid == (DPID_BRIGHTNESS_MIN_1 + i*16)){
			ret = mcu_dp_value_update(dpid,(unsigned long)deviceInfo.driver[i].dimLevelMin);
			return ret;
		}
		else if(dpid == (DPID_LED_TYPE_1 + i*16)){
			ret = mcu_dp_enum_update(dpid, deviceInfo.driver[i].lamType);
			return ret;
		}
		else if(dpid == (DPID_BRIGHTNESS_MAX_1 + i*16)){
			ret = mcu_dp_value_update(dpid,deviceInfo.driver[i].dimLevelMax);
			return ret;
		}
		else if(dpid == (DPID_TRANSACTION_1 +i*16)){
			ret = mcu_dp_value_update(dpid,deviceInfo.driver[i].transaction);
			return ret;
		}
		else if(dpid == (DPID_LIGHT_MODE_1 +i*16)){
			ret = mcu_dp_bool_update(dpid,deviceInfo.driver[i].lightMode);
			return ret;
		}
		else if(dpid == (DPID_CCT_OR_HSL_1 +i*16)){ //new
			respond_cct_or_hsl(i);
			
			return ret;
		}
		else if(dpid == (DPID_TERMP_OR_HUE_1 +i*16)){
			
#ifdef DEVICE_LED_STRING_RGB //RGB hsl para:
		ret = mcu_dp_value_update(dpid,deviceInfo.driver[i].hue);
#else //CCT Lamp: cct para
		ret = mcu_dp_value_update(dpid,deviceInfo.driver[i].temperaColor);
#endif
			return ret;
		}
		else if(dpid == (DPID_SATURATION_1 +i*16)){
			ret = mcu_dp_value_update(dpid,deviceInfo.driver[i].saturation);
			
			return ret;
		}
	}
	
	if(dpid == (DPID_RESTART_STATUS )){  
		ret =  mcu_dp_enum_update(DPID_RESTART_STATUS,deviceInfo.driver[0].restartStauts);
	}
  return ret;
}
/**
* @brief get received cmd total number
* @param[in] {void}   
* @return  received cmd total number
*/
unsigned char get_download_cmd_total(void)
{
  return cmd_total;
}


/**
* @brief received rf net_work state handle 
* @param[in] {rf_work_state}  rf current network state
* @return  void 
*/
void rf_work_state_event(unsigned char rf_work_state)
{	
	unsigned short length= 0;
	rf_uart_write_frame(ZIGBEE_STATE_CMD, length);	
  deviceInfo.networkStatus  = rf_work_state;
	
	switch(rf_work_state){
		case ZIGBEE_NOT_JION:	

			break;
		
		case ZIGBEE_JOIN_GATEWAY:	

			break;
		
		case ZIGBEE_JOIN_ERROR:	

			break;
		
		case ZIGBEE_JOINING:	

			break;
		
		default:
			break;
	}
}


/**
* @brief received reset rf response 
* @param[in] {state} response state 
* @return  void 
*/
void mcu_reset_rf_event(unsigned char state)
{	
	switch(state){
		case RESET_ZIGBEE_OK:
		
			break;
		
		case RESET_ZIGBEE_ERROR:
		
			break;
		
		default:
			break;
	}
}


/**
* @brief check mcu version response
* @param[in] {void}
* @return  void 
*/
void response_mcu_ota_version_event(void)
{
	unsigned short length = 0;
	length = set_rf_uart_byte(length,get_current_mcu_fw_ver());	//current fw version
	rf_uart_write_frame(MCU_OTA_VERSION_CMD,length);
}

#ifdef SUPPORT_MCU_OTA
/**
* @brief mcu ota update notify response
* @param[in] {offset} data offset 
* @return  void 
*/
void response_mcu_ota_notify_event(unsigned char offset)
{
	unsigned char i = 0;
	unsigned short length = 0;
	
	current_mcu_fw_pid();	//current PID
	
	while(i<8){
		ota_fw_info.mcu_ota_pid[i] = rf_uart_rx_buf[offset + DATA_START + i];								//ota fw PID
		i++;
	}
	ota_fw_info.mcu_ota_ver = rf_uart_rx_buf[offset + DATA_START + 8];											//ota fw version
	ota_fw_info.mcu_ota_fw_size = rf_uart_rx_buf[offset + DATA_START + 9] << 24 | \
																rf_uart_rx_buf[offset +DATA_START + 10] << 16 | \
																rf_uart_rx_buf[offset + DATA_START + 11] << 8 | \
																rf_uart_rx_buf[offset + DATA_START + 12];								//ota fw size
	ota_fw_info.mcu_ota_checksum = rf_uart_rx_buf[offset + DATA_START + 13] << 24 | \
																 rf_uart_rx_buf[offset + DATA_START + 14] << 16 | \
																 rf_uart_rx_buf[offset + DATA_START + 15] << 8 | \
																 rf_uart_rx_buf[offset + DATA_START + 16];								//ota fw checksum
	
	if((!strcmp_barry(&ota_fw_info.mcu_ota_pid[0],&current_mcu_pid[0],8)) && \
		 (ota_fw_info.mcu_ota_ver > get_current_mcu_fw_ver() &&\
		  ota_fw_info.mcu_ota_fw_size > 0)	
		){		//check fw pid and fw version and fw size
		length = set_rf_uart_byte(length,0x00);	//OK
	}
	else{
		length = set_rf_uart_byte(length,0x01);	//error
	}
    ota_fw_info.mcu_current_offset = 0;
	rf_uart_write_frame(MCU_OTA_NOTIFY_CMD,length);
}


/**
* @brief received mcu ota data request response
* @param[in] {fw_offset}  offset of file 
* @param[in] {data}  received data  
* @return  void 
*/
void reveived_mcu_ota_data_handle(unsigned int fw_offset,char *data)
{
	#error "received frame data, should save in flash, mcu should realize this fuction, and delete this line "
}

/**
* @brief mcu send ota data request 
* @param[in] {void}  
* @return  void 
*/
void mcu_ota_fw_request_event(unsigned char offset)
{	
	unsigned int fw_offset = 0;
	char fw_data[FW_SINGLE_PACKET_SIZE] = {-1};	//
	unsigned char i = 0;
	unsigned char last_package_len = 0;
	static unsigned int current_checksum = 0;

	if(rf_uart_rx_buf[offset + DATA_START] == 0x01)				//status check
		return;
	while(i < 8){
		if(current_mcu_pid[i] != rf_uart_rx_buf[offset + DATA_START + 1 + i])	//pid check
			return;
		i++;
	}
	if(ota_fw_info.mcu_ota_ver != rf_uart_rx_buf[offset + DATA_START + 9]) //version check
		return;
	
	i = 0;
	while(i < 4){
		fw_offset |= (rf_uart_rx_buf[offset + DATA_START + 10 + i] << (24 - i * 8));		//offset
		i++;
	}
	i = 0;
	if(ota_fw_info.mcu_current_offset ==  fw_offset)
	{
		if((ota_fw_info.mcu_ota_fw_size - fw_offset) / FW_SINGLE_PACKET_SIZE != 0){
			if(ota_fw_info.mcu_current_offset == 0){
				current_checksum = 0;
			}
			while(i < FW_SINGLE_PACKET_SIZE){
				fw_data[i] = rf_uart_rx_buf[offset + DATA_START + 14 + i];   //fw data
				current_checksum += fw_data[i];
				i++;
			}
			ota_fw_info.mcu_current_offset += FW_SINGLE_PACKET_SIZE;
			ota_fw_data_handle(fw_offset,&fw_data[0],FW_SINGLE_PACKET_SIZE);	//OTA paket data handle
		}
		else {
			i = 0;
			last_package_len = ota_fw_info.mcu_ota_fw_size - fw_offset;
			while(i < last_package_len){
				fw_data[i] = rf_uart_rx_buf[offset + DATA_START + 14 + i];
				current_checksum += fw_data[i];
				i++;
			}
			ota_fw_info.mcu_current_offset += last_package_len;
			if(ota_fw_info.mcu_ota_checksum != current_checksum){
				//ota failure report ota failure and clear ota struct 
				mcu_ota_result_report(1); // failed
			}	
			else{
				//ota sucess 
				mcu_ota_result_report(0); // seccess
			}
			ota_fw_data_handle(fw_offset,&fw_data[0],last_package_len);	//OTA paket data handle		
			current_checksum = 0;															
		}
	}
	else
	{
		// ota request timeout, then restart ota request from  ota_fw_info.mcu_ota_fw_size
	}
}

static void report_mcu_ota_result(unsigned char  res)
{
	unsigned short length;
	if((res==0)||(res == 1))
	{
		length = set_rf_uart_byte(length,res);	
		rf_uart_write_frame(MCU_OTA_NOTIFY_CMD,length);
	}
}


/**
* @brief mcu ota data result notify
* @param[in] {void} 
* @return  void 
*/
void mcu_ota_result_event(unsigned char offset)
{
	unsigned char status = rf_uart_rx_buf[offset + DATA_START];
	
	if(status == 0x00){
	}
	else if(status == 0x01)	{

	}
}

/**
* @brief mcu ota data handle 
* @param[in] {fw_offset} frame offset 
* @param[in] {data} received data
* @return  void 
*/
void ota_fw_data_handle(unsigned int fw_offset,char *data,unsigned char data_len)
{
	#error "请在该函数处理固件包数据,并删除该行"
}
#endif


#ifdef  BEACON_TEST
/**
* @brief beacon test notify,which used in testing
* @param[in] {void} 
* @return  void 
*/
void mcu_received_beacon_test_handle(void)
{
	unsigned short length = 0;
	length = set_rf_uart_byte(length,0x00);	
	rf_uart_write_frame(SEND_BEACON_NOTIFY_CMD,length);
	// then start test
}
#endif

#ifdef  CHECK_ZIGBEE_NETWORK
/**
* @brief check rf nwkstate,before start join nwk, check nwk if state is not 0x02,can start jion,
* else delay 5s 
*
* @param[in] {void} 
* @return  void 
*/
void mcu_check_rf_nwk_state(void)
{
	unsigned short length = 0;
	rf_uart_write_frame(CHECK_ZIGBEE_NETWORK_CMD,length);
	// then start test
}
#endif

void rf_notify_factory_new_hanlde(void)
{
	unsigned short length = 0;
	length = set_rf_uart_byte(length,0x01);	
	rf_uart_write_frame(ZIGBEE_FACTORY_NEW_CMD,length);
	// then start test
}


#ifdef READ_DP_DATA_NOTIFY
/**
* @brief when gateway repower or relink clould, or rf module join sucess, repower, this commod will notify 
* mcu, to sys dp data, mcu itself decide whether report.
*
* @param[in] {void} 
* @return  void 
*/
void read_dp_data_notify_hanlde(void)
{
	unsigned short length = 0;
	length = set_rf_uart_byte(length,0x01);	
	rf_uart_write_frame(ZIGBEE_FACTORY_NEW_CMD,length);
	// then start test
}
#endif 


